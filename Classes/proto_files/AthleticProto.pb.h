// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AthleticProto.proto

#ifndef PROTOBUF_AthleticProto_2eproto__INCLUDED
#define PROTOBUF_AthleticProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace tiange {
namespace mdsj {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AthleticProto_2eproto();
void protobuf_AssignDesc_AthleticProto_2eproto();
void protobuf_ShutdownFile_AthleticProto_2eproto();

class ModeListRequest;
class ModeListResponse;
class ModeListResponse_Mode;
class RoomListRequest;
class RoomListResponse;
class RoomListResponse_Room;
class CreateRoomRequest;
class CreateRoomResponse;
class EnterRoomRequest;
class EnterRoomResponse;
class EnterRoomResponse_Member;
class SearchRoomRequest;
class SearchRoomResponse;
class FastEnterRequest;
class FastEnterResponse;
class FastEnterResponse_Member;
class ModifyRequest;
class ModifyResponse;
class StartRequest;
class StartResponse;
class PrepareRequest;
class PrepareResponse;
class OnlinesRequest;
class OnlinesResponse;
class OnlinesResponse_User;
class InviteRequest;
class InviteResponse;
class SearchRoleRequest;
class SearchRoleResponse;
class ExitRequest;
class ExitResponse;
class InvitePush;
class RefusePush;
class RoomStatusPush;
class MapChangePush;
class RoleChangePush;

// ===================================================================

class ModeListRequest : public ::google::protobuf::Message {
 public:
  ModeListRequest();
  virtual ~ModeListRequest();

  ModeListRequest(const ModeListRequest& from);

  inline ModeListRequest& operator=(const ModeListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModeListRequest& default_instance();

  void Swap(ModeListRequest* other);

  // implements Message ----------------------------------------------

  ModeListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModeListRequest& from);
  void MergeFrom(const ModeListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ModeListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ModeListRequest* default_instance_;
};
// -------------------------------------------------------------------

class ModeListResponse_Mode : public ::google::protobuf::Message {
 public:
  ModeListResponse_Mode();
  virtual ~ModeListResponse_Mode();

  ModeListResponse_Mode(const ModeListResponse_Mode& from);

  inline ModeListResponse_Mode& operator=(const ModeListResponse_Mode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModeListResponse_Mode& default_instance();

  void Swap(ModeListResponse_Mode* other);

  // implements Message ----------------------------------------------

  ModeListResponse_Mode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModeListResponse_Mode& from);
  void MergeFrom(const ModeListResponse_Mode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string icon = 3;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 3;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // required int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // required string desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required bool team = 6;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 6;
  inline bool team() const;
  inline void set_team(bool value);

  // repeated string maps = 7;
  inline int maps_size() const;
  inline void clear_maps();
  static const int kMapsFieldNumber = 7;
  inline const ::std::string& maps(int index) const;
  inline ::std::string* mutable_maps(int index);
  inline void set_maps(int index, const ::std::string& value);
  inline void set_maps(int index, const char* value);
  inline void set_maps(int index, const char* value, size_t size);
  inline ::std::string* add_maps();
  inline void add_maps(const ::std::string& value);
  inline void add_maps(const char* value);
  inline void add_maps(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& maps() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_maps();

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ModeListResponse.Mode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* icon_;
  ::std::string* desc_;
  ::google::protobuf::int32 limit_;
  bool team_;
  ::google::protobuf::RepeatedPtrField< ::std::string> maps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ModeListResponse_Mode* default_instance_;
};
// -------------------------------------------------------------------

class ModeListResponse : public ::google::protobuf::Message {
 public:
  ModeListResponse();
  virtual ~ModeListResponse();

  ModeListResponse(const ModeListResponse& from);

  inline ModeListResponse& operator=(const ModeListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModeListResponse& default_instance();

  void Swap(ModeListResponse* other);

  // implements Message ----------------------------------------------

  ModeListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModeListResponse& from);
  void MergeFrom(const ModeListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ModeListResponse_Mode Mode;

  // accessors -------------------------------------------------------

  // repeated .com.tiange.mdsj.proto.ModeListResponse.Mode modes = 1;
  inline int modes_size() const;
  inline void clear_modes();
  static const int kModesFieldNumber = 1;
  inline const ::com::tiange::mdsj::proto::ModeListResponse_Mode& modes(int index) const;
  inline ::com::tiange::mdsj::proto::ModeListResponse_Mode* mutable_modes(int index);
  inline ::com::tiange::mdsj::proto::ModeListResponse_Mode* add_modes();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::ModeListResponse_Mode >&
      modes() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::ModeListResponse_Mode >*
      mutable_modes();

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ModeListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::ModeListResponse_Mode > modes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ModeListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoomListRequest : public ::google::protobuf::Message {
 public:
  RoomListRequest();
  virtual ~RoomListRequest();

  RoomListRequest(const RoomListRequest& from);

  inline RoomListRequest& operator=(const RoomListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListRequest& default_instance();

  void Swap(RoomListRequest* other);

  // implements Message ----------------------------------------------

  RoomListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListRequest& from);
  void MergeFrom(const RoomListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.RoomListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static RoomListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RoomListResponse_Room : public ::google::protobuf::Message {
 public:
  RoomListResponse_Room();
  virtual ~RoomListResponse_Room();

  RoomListResponse_Room(const RoomListResponse_Room& from);

  inline RoomListResponse_Room& operator=(const RoomListResponse_Room& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListResponse_Room& default_instance();

  void Swap(RoomListResponse_Room* other);

  // implements Message ----------------------------------------------

  RoomListResponse_Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListResponse_Room& from);
  void MergeFrom(const RoomListResponse_Room& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 leader = 3;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 3;
  inline ::google::protobuf::int32 leader() const;
  inline void set_leader(::google::protobuf::int32 value);

  // required string nick = 4;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 4;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required string modeId = 5;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 5;
  inline const ::std::string& modeid() const;
  inline void set_modeid(const ::std::string& value);
  inline void set_modeid(const char* value);
  inline void set_modeid(const char* value, size_t size);
  inline ::std::string* mutable_modeid();
  inline ::std::string* release_modeid();
  inline void set_allocated_modeid(::std::string* modeid);

  // required int32 limit = 6;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 6;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // required int32 num = 7;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 7;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required bool needPwd = 8;
  inline bool has_needpwd() const;
  inline void clear_needpwd();
  static const int kNeedPwdFieldNumber = 8;
  inline bool needpwd() const;
  inline void set_needpwd(bool value);

  // required string map = 9;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 9;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // required int32 level = 10;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 10;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 time = 11;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 11;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.RoomListResponse.Room)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_needpwd();
  inline void clear_has_needpwd();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* nick_;
  ::google::protobuf::int32 leader_;
  ::google::protobuf::int32 limit_;
  ::std::string* modeid_;
  ::google::protobuf::int32 num_;
  bool needpwd_;
  ::std::string* map_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static RoomListResponse_Room* default_instance_;
};
// -------------------------------------------------------------------

class RoomListResponse : public ::google::protobuf::Message {
 public:
  RoomListResponse();
  virtual ~RoomListResponse();

  RoomListResponse(const RoomListResponse& from);

  inline RoomListResponse& operator=(const RoomListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListResponse& default_instance();

  void Swap(RoomListResponse* other);

  // implements Message ----------------------------------------------

  RoomListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListResponse& from);
  void MergeFrom(const RoomListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomListResponse_Room Room;

  // accessors -------------------------------------------------------

  // repeated .com.tiange.mdsj.proto.RoomListResponse.Room rooms = 1;
  inline int rooms_size() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  inline const ::com::tiange::mdsj::proto::RoomListResponse_Room& rooms(int index) const;
  inline ::com::tiange::mdsj::proto::RoomListResponse_Room* mutable_rooms(int index);
  inline ::com::tiange::mdsj::proto::RoomListResponse_Room* add_rooms();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::RoomListResponse_Room >&
      rooms() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::RoomListResponse_Room >*
      mutable_rooms();

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.RoomListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::RoomListResponse_Room > rooms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static RoomListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomRequest : public ::google::protobuf::Message {
 public:
  CreateRoomRequest();
  virtual ~CreateRoomRequest();

  CreateRoomRequest(const CreateRoomRequest& from);

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRequest& default_instance();

  void Swap(CreateRoomRequest* other);

  // implements Message ----------------------------------------------

  CreateRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string modeId = 1;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 1;
  inline const ::std::string& modeid() const;
  inline void set_modeid(const ::std::string& value);
  inline void set_modeid(const char* value);
  inline void set_modeid(const char* value, size_t size);
  inline ::std::string* mutable_modeid();
  inline ::std::string* release_modeid();
  inline void set_allocated_modeid(::std::string* modeid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string pwd = 3;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 3;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // required int32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // required int32 match = 5;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 5;
  inline ::google::protobuf::int32 match() const;
  inline void set_match(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.CreateRoomRequest)
 private:
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_match();
  inline void clear_has_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* modeid_;
  ::std::string* name_;
  ::std::string* pwd_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 match_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomResponse : public ::google::protobuf::Message {
 public:
  CreateRoomResponse();
  virtual ~CreateRoomResponse();

  CreateRoomResponse(const CreateRoomResponse& from);

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomResponse& default_instance();

  void Swap(CreateRoomResponse* other);

  // implements Message ----------------------------------------------

  CreateRoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomResponse& from);
  void MergeFrom(const CreateRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string map = 4;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 4;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // optional int32 role = 5;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 5;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // optional string nick = 6;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 6;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional int32 level = 7;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 7;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional string avatar = 8;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 8;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.CreateRoomResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 role_;
  ::std::string* map_;
  ::std::string* nick_;
  ::std::string* avatar_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomRequest : public ::google::protobuf::Message {
 public:
  EnterRoomRequest();
  virtual ~EnterRoomRequest();

  EnterRoomRequest(const EnterRoomRequest& from);

  inline EnterRoomRequest& operator=(const EnterRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomRequest& default_instance();

  void Swap(EnterRoomRequest* other);

  // implements Message ----------------------------------------------

  EnterRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomRequest& from);
  void MergeFrom(const EnterRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.EnterRoomRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomResponse_Member : public ::google::protobuf::Message {
 public:
  EnterRoomResponse_Member();
  virtual ~EnterRoomResponse_Member();

  EnterRoomResponse_Member(const EnterRoomResponse_Member& from);

  inline EnterRoomResponse_Member& operator=(const EnterRoomResponse_Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomResponse_Member& default_instance();

  void Swap(EnterRoomResponse_Member* other);

  // implements Message ----------------------------------------------

  EnterRoomResponse_Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomResponse_Member& from);
  void MergeFrom(const EnterRoomResponse_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string avatar = 4;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required bool leader = 5;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 5;
  inline bool leader() const;
  inline void set_leader(bool value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.EnterRoomResponse.Member)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_leader();
  inline void clear_has_leader();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_;
  ::std::string* nick_;
  ::std::string* avatar_;
  ::google::protobuf::int32 level_;
  bool leader_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomResponse_Member* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomResponse : public ::google::protobuf::Message {
 public:
  EnterRoomResponse();
  virtual ~EnterRoomResponse();

  EnterRoomResponse(const EnterRoomResponse& from);

  inline EnterRoomResponse& operator=(const EnterRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomResponse& default_instance();

  void Swap(EnterRoomResponse* other);

  // implements Message ----------------------------------------------

  EnterRoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomResponse& from);
  void MergeFrom(const EnterRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnterRoomResponse_Member Member;

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string map = 4;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 4;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // repeated .com.tiange.mdsj.proto.EnterRoomResponse.Member members = 5;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 5;
  inline const ::com::tiange::mdsj::proto::EnterRoomResponse_Member& members(int index) const;
  inline ::com::tiange::mdsj::proto::EnterRoomResponse_Member* mutable_members(int index);
  inline ::com::tiange::mdsj::proto::EnterRoomResponse_Member* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::EnterRoomResponse_Member >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::EnterRoomResponse_Member >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.EnterRoomResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* map_;
  ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::EnterRoomResponse_Member > members_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class SearchRoomRequest : public ::google::protobuf::Message {
 public:
  SearchRoomRequest();
  virtual ~SearchRoomRequest();

  SearchRoomRequest(const SearchRoomRequest& from);

  inline SearchRoomRequest& operator=(const SearchRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRoomRequest& default_instance();

  void Swap(SearchRoomRequest* other);

  // implements Message ----------------------------------------------

  SearchRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRoomRequest& from);
  void MergeFrom(const SearchRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.SearchRoomRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static SearchRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchRoomResponse : public ::google::protobuf::Message {
 public:
  SearchRoomResponse();
  virtual ~SearchRoomResponse();

  SearchRoomResponse(const SearchRoomResponse& from);

  inline SearchRoomResponse& operator=(const SearchRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRoomResponse& default_instance();

  void Swap(SearchRoomResponse* other);

  // implements Message ----------------------------------------------

  SearchRoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRoomResponse& from);
  void MergeFrom(const SearchRoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline bool status() const;
  inline void set_status(bool value);

  // optional bool needPwd = 5;
  inline bool has_needpwd() const;
  inline void clear_needpwd();
  static const int kNeedPwdFieldNumber = 5;
  inline bool needpwd() const;
  inline void set_needpwd(bool value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.SearchRoomResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_needpwd();
  inline void clear_has_needpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::int32 result_;
  bool status_;
  bool needpwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static SearchRoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class FastEnterRequest : public ::google::protobuf::Message {
 public:
  FastEnterRequest();
  virtual ~FastEnterRequest();

  FastEnterRequest(const FastEnterRequest& from);

  inline FastEnterRequest& operator=(const FastEnterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FastEnterRequest& default_instance();

  void Swap(FastEnterRequest* other);

  // implements Message ----------------------------------------------

  FastEnterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FastEnterRequest& from);
  void MergeFrom(const FastEnterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.FastEnterRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static FastEnterRequest* default_instance_;
};
// -------------------------------------------------------------------

class FastEnterResponse_Member : public ::google::protobuf::Message {
 public:
  FastEnterResponse_Member();
  virtual ~FastEnterResponse_Member();

  FastEnterResponse_Member(const FastEnterResponse_Member& from);

  inline FastEnterResponse_Member& operator=(const FastEnterResponse_Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FastEnterResponse_Member& default_instance();

  void Swap(FastEnterResponse_Member* other);

  // implements Message ----------------------------------------------

  FastEnterResponse_Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FastEnterResponse_Member& from);
  void MergeFrom(const FastEnterResponse_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string avatar = 4;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required bool leader = 5;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 5;
  inline bool leader() const;
  inline void set_leader(bool value);

  // required int32 index = 6;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 6;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.FastEnterResponse.Member)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nick_;
  ::google::protobuf::int32 role_;
  ::google::protobuf::int32 level_;
  ::std::string* avatar_;
  bool leader_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static FastEnterResponse_Member* default_instance_;
};
// -------------------------------------------------------------------

class FastEnterResponse : public ::google::protobuf::Message {
 public:
  FastEnterResponse();
  virtual ~FastEnterResponse();

  FastEnterResponse(const FastEnterResponse& from);

  inline FastEnterResponse& operator=(const FastEnterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FastEnterResponse& default_instance();

  void Swap(FastEnterResponse* other);

  // implements Message ----------------------------------------------

  FastEnterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FastEnterResponse& from);
  void MergeFrom(const FastEnterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FastEnterResponse_Member Member;

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string map = 4;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 4;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // repeated .com.tiange.mdsj.proto.FastEnterResponse.Member members = 5;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 5;
  inline const ::com::tiange::mdsj::proto::FastEnterResponse_Member& members(int index) const;
  inline ::com::tiange::mdsj::proto::FastEnterResponse_Member* mutable_members(int index);
  inline ::com::tiange::mdsj::proto::FastEnterResponse_Member* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::FastEnterResponse_Member >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::FastEnterResponse_Member >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.FastEnterResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::std::string* map_;
  ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::FastEnterResponse_Member > members_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static FastEnterResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModifyRequest : public ::google::protobuf::Message {
 public:
  ModifyRequest();
  virtual ~ModifyRequest();

  ModifyRequest(const ModifyRequest& from);

  inline ModifyRequest& operator=(const ModifyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyRequest& default_instance();

  void Swap(ModifyRequest* other);

  // implements Message ----------------------------------------------

  ModifyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyRequest& from);
  void MergeFrom(const ModifyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ModifyRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ModifyRequest* default_instance_;
};
// -------------------------------------------------------------------

class ModifyResponse : public ::google::protobuf::Message {
 public:
  ModifyResponse();
  virtual ~ModifyResponse();

  ModifyResponse(const ModifyResponse& from);

  inline ModifyResponse& operator=(const ModifyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyResponse& default_instance();

  void Swap(ModifyResponse* other);

  // implements Message ----------------------------------------------

  ModifyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyResponse& from);
  void MergeFrom(const ModifyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ModifyResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ModifyResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartRequest : public ::google::protobuf::Message {
 public:
  StartRequest();
  virtual ~StartRequest();

  StartRequest(const StartRequest& from);

  inline StartRequest& operator=(const StartRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRequest& default_instance();

  void Swap(StartRequest* other);

  // implements Message ----------------------------------------------

  StartRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartRequest& from);
  void MergeFrom(const StartRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.StartRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static StartRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartResponse : public ::google::protobuf::Message {
 public:
  StartResponse();
  virtual ~StartResponse();

  StartResponse(const StartResponse& from);

  inline StartResponse& operator=(const StartResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartResponse& default_instance();

  void Swap(StartResponse* other);

  // implements Message ----------------------------------------------

  StartResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartResponse& from);
  void MergeFrom(const StartResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.StartResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static StartResponse* default_instance_;
};
// -------------------------------------------------------------------

class PrepareRequest : public ::google::protobuf::Message {
 public:
  PrepareRequest();
  virtual ~PrepareRequest();

  PrepareRequest(const PrepareRequest& from);

  inline PrepareRequest& operator=(const PrepareRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareRequest& default_instance();

  void Swap(PrepareRequest* other);

  // implements Message ----------------------------------------------

  PrepareRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepareRequest& from);
  void MergeFrom(const PrepareRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.PrepareRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static PrepareRequest* default_instance_;
};
// -------------------------------------------------------------------

class PrepareResponse : public ::google::protobuf::Message {
 public:
  PrepareResponse();
  virtual ~PrepareResponse();

  PrepareResponse(const PrepareResponse& from);

  inline PrepareResponse& operator=(const PrepareResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrepareResponse& default_instance();

  void Swap(PrepareResponse* other);

  // implements Message ----------------------------------------------

  PrepareResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrepareResponse& from);
  void MergeFrom(const PrepareResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.PrepareResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static PrepareResponse* default_instance_;
};
// -------------------------------------------------------------------

class OnlinesRequest : public ::google::protobuf::Message {
 public:
  OnlinesRequest();
  virtual ~OnlinesRequest();

  OnlinesRequest(const OnlinesRequest& from);

  inline OnlinesRequest& operator=(const OnlinesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlinesRequest& default_instance();

  void Swap(OnlinesRequest* other);

  // implements Message ----------------------------------------------

  OnlinesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlinesRequest& from);
  void MergeFrom(const OnlinesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.OnlinesRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static OnlinesRequest* default_instance_;
};
// -------------------------------------------------------------------

class OnlinesResponse_User : public ::google::protobuf::Message {
 public:
  OnlinesResponse_User();
  virtual ~OnlinesResponse_User();

  OnlinesResponse_User(const OnlinesResponse_User& from);

  inline OnlinesResponse_User& operator=(const OnlinesResponse_User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlinesResponse_User& default_instance();

  void Swap(OnlinesResponse_User* other);

  // implements Message ----------------------------------------------

  OnlinesResponse_User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlinesResponse_User& from);
  void MergeFrom(const OnlinesResponse_User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string avatar = 4;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required bool sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline bool sex() const;
  inline void set_sex(bool value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.OnlinesResponse.User)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nick_;
  ::google::protobuf::int32 role_;
  ::google::protobuf::int32 level_;
  ::std::string* avatar_;
  bool sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static OnlinesResponse_User* default_instance_;
};
// -------------------------------------------------------------------

class OnlinesResponse : public ::google::protobuf::Message {
 public:
  OnlinesResponse();
  virtual ~OnlinesResponse();

  OnlinesResponse(const OnlinesResponse& from);

  inline OnlinesResponse& operator=(const OnlinesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlinesResponse& default_instance();

  void Swap(OnlinesResponse* other);

  // implements Message ----------------------------------------------

  OnlinesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlinesResponse& from);
  void MergeFrom(const OnlinesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OnlinesResponse_User User;

  // accessors -------------------------------------------------------

  // repeated .com.tiange.mdsj.proto.OnlinesResponse.User users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::com::tiange::mdsj::proto::OnlinesResponse_User& users(int index) const;
  inline ::com::tiange::mdsj::proto::OnlinesResponse_User* mutable_users(int index);
  inline ::com::tiange::mdsj::proto::OnlinesResponse_User* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::OnlinesResponse_User >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::OnlinesResponse_User >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.OnlinesResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::OnlinesResponse_User > users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static OnlinesResponse* default_instance_;
};
// -------------------------------------------------------------------

class InviteRequest : public ::google::protobuf::Message {
 public:
  InviteRequest();
  virtual ~InviteRequest();

  InviteRequest(const InviteRequest& from);

  inline InviteRequest& operator=(const InviteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteRequest& default_instance();

  void Swap(InviteRequest* other);

  // implements Message ----------------------------------------------

  InviteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteRequest& from);
  void MergeFrom(const InviteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.InviteRequest)
 private:
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static InviteRequest* default_instance_;
};
// -------------------------------------------------------------------

class InviteResponse : public ::google::protobuf::Message {
 public:
  InviteResponse();
  virtual ~InviteResponse();

  InviteResponse(const InviteResponse& from);

  inline InviteResponse& operator=(const InviteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteResponse& default_instance();

  void Swap(InviteResponse* other);

  // implements Message ----------------------------------------------

  InviteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteResponse& from);
  void MergeFrom(const InviteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.InviteResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static InviteResponse* default_instance_;
};
// -------------------------------------------------------------------

class SearchRoleRequest : public ::google::protobuf::Message {
 public:
  SearchRoleRequest();
  virtual ~SearchRoleRequest();

  SearchRoleRequest(const SearchRoleRequest& from);

  inline SearchRoleRequest& operator=(const SearchRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRoleRequest& default_instance();

  void Swap(SearchRoleRequest* other);

  // implements Message ----------------------------------------------

  SearchRoleRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRoleRequest& from);
  void MergeFrom(const SearchRoleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.SearchRoleRequest)
 private:
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static SearchRoleRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchRoleResponse : public ::google::protobuf::Message {
 public:
  SearchRoleResponse();
  virtual ~SearchRoleResponse();

  SearchRoleResponse(const SearchRoleResponse& from);

  inline SearchRoleResponse& operator=(const SearchRoleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRoleResponse& default_instance();

  void Swap(SearchRoleResponse* other);

  // implements Message ----------------------------------------------

  SearchRoleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchRoleResponse& from);
  void MergeFrom(const SearchRoleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string avatar = 4;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required bool sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline bool sex() const;
  inline void set_sex(bool value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.SearchRoleResponse)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nick_;
  ::google::protobuf::int32 role_;
  ::google::protobuf::int32 level_;
  ::std::string* avatar_;
  bool sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static SearchRoleResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExitRequest : public ::google::protobuf::Message {
 public:
  ExitRequest();
  virtual ~ExitRequest();

  ExitRequest(const ExitRequest& from);

  inline ExitRequest& operator=(const ExitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitRequest& default_instance();

  void Swap(ExitRequest* other);

  // implements Message ----------------------------------------------

  ExitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitRequest& from);
  void MergeFrom(const ExitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ExitRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ExitRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExitResponse : public ::google::protobuf::Message {
 public:
  ExitResponse();
  virtual ~ExitResponse();

  ExitResponse(const ExitResponse& from);

  inline ExitResponse& operator=(const ExitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExitResponse& default_instance();

  void Swap(ExitResponse* other);

  // implements Message ----------------------------------------------

  ExitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExitResponse& from);
  void MergeFrom(const ExitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.ExitResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static ExitResponse* default_instance_;
};
// -------------------------------------------------------------------

class InvitePush : public ::google::protobuf::Message {
 public:
  InvitePush();
  virtual ~InvitePush();

  InvitePush(const InvitePush& from);

  inline InvitePush& operator=(const InvitePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitePush& default_instance();

  void Swap(InvitePush* other);

  // implements Message ----------------------------------------------

  InvitePush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvitePush& from);
  void MergeFrom(const InvitePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required string room = 3;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 3;
  inline const ::std::string& room() const;
  inline void set_room(const ::std::string& value);
  inline void set_room(const char* value);
  inline void set_room(const char* value, size_t size);
  inline ::std::string* mutable_room();
  inline ::std::string* release_room();
  inline void set_allocated_room(::std::string* room);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.InvitePush)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nick_;
  ::std::string* room_;
  ::google::protobuf::int32 role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static InvitePush* default_instance_;
};
// -------------------------------------------------------------------

class RefusePush : public ::google::protobuf::Message {
 public:
  RefusePush();
  virtual ~RefusePush();

  RefusePush(const RefusePush& from);

  inline RefusePush& operator=(const RefusePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefusePush& default_instance();

  void Swap(RefusePush* other);

  // implements Message ----------------------------------------------

  RefusePush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RefusePush& from);
  void MergeFrom(const RefusePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 role = 1;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 1;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.RefusePush)
 private:
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nick_;
  ::google::protobuf::int32 role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static RefusePush* default_instance_;
};
// -------------------------------------------------------------------

class RoomStatusPush : public ::google::protobuf::Message {
 public:
  RoomStatusPush();
  virtual ~RoomStatusPush();

  RoomStatusPush(const RoomStatusPush& from);

  inline RoomStatusPush& operator=(const RoomStatusPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomStatusPush& default_instance();

  void Swap(RoomStatusPush* other);

  // implements Message ----------------------------------------------

  RoomStatusPush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomStatusPush& from);
  void MergeFrom(const RoomStatusPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 leader = 4;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 4;
  inline ::google::protobuf::int32 leader() const;
  inline void set_leader(::google::protobuf::int32 value);

  // required string nick = 5;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 5;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required string modeId = 6;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 6;
  inline const ::std::string& modeid() const;
  inline void set_modeid(const ::std::string& value);
  inline void set_modeid(const char* value);
  inline void set_modeid(const char* value, size_t size);
  inline ::std::string* mutable_modeid();
  inline ::std::string* release_modeid();
  inline void set_allocated_modeid(::std::string* modeid);

  // required int32 limit = 7;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 7;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // required int32 num = 8;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 8;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required bool needPwd = 9;
  inline bool has_needpwd() const;
  inline void clear_needpwd();
  static const int kNeedPwdFieldNumber = 9;
  inline bool needpwd() const;
  inline void set_needpwd(bool value);

  // required string map = 10;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 10;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // required int32 level = 11;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 11;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 time = 12;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 12;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.RoomStatusPush)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_needpwd();
  inline void clear_has_needpwd();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 leader_;
  ::std::string* name_;
  ::std::string* nick_;
  ::std::string* modeid_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 num_;
  ::std::string* map_;
  bool needpwd_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static RoomStatusPush* default_instance_;
};
// -------------------------------------------------------------------

class MapChangePush : public ::google::protobuf::Message {
 public:
  MapChangePush();
  virtual ~MapChangePush();

  MapChangePush(const MapChangePush& from);

  inline MapChangePush& operator=(const MapChangePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapChangePush& default_instance();

  void Swap(MapChangePush* other);

  // implements Message ----------------------------------------------

  MapChangePush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapChangePush& from);
  void MergeFrom(const MapChangePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string map = 1;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 1;
  inline const ::std::string& map() const;
  inline void set_map(const ::std::string& value);
  inline void set_map(const char* value);
  inline void set_map(const char* value, size_t size);
  inline ::std::string* mutable_map();
  inline ::std::string* release_map();
  inline void set_allocated_map(::std::string* map);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.MapChangePush)
 private:
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static MapChangePush* default_instance_;
};
// -------------------------------------------------------------------

class RoleChangePush : public ::google::protobuf::Message {
 public:
  RoleChangePush();
  virtual ~RoleChangePush();

  RoleChangePush(const RoleChangePush& from);

  inline RoleChangePush& operator=(const RoleChangePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleChangePush& default_instance();

  void Swap(RoleChangePush* other);

  // implements Message ----------------------------------------------

  RoleChangePush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleChangePush& from);
  void MergeFrom(const RoleChangePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 role = 2;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 2;
  inline ::google::protobuf::int32 role() const;
  inline void set_role(::google::protobuf::int32 value);

  // required string nick = 3;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 3;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string avatar = 5;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 5;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required bool leader = 6;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 6;
  inline bool leader() const;
  inline void set_leader(bool value);

  // required int32 index = 7;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 7;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tiange.mdsj.proto.RoleChangePush)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 role_;
  ::std::string* nick_;
  ::std::string* avatar_;
  ::google::protobuf::int32 level_;
  bool leader_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AthleticProto_2eproto();
  friend void protobuf_AssignDesc_AthleticProto_2eproto();
  friend void protobuf_ShutdownFile_AthleticProto_2eproto();

  void InitAsDefaultInstance();
  static RoleChangePush* default_instance_;
};
// ===================================================================


// ===================================================================

// ModeListRequest

// -------------------------------------------------------------------

// ModeListResponse_Mode

// required string id = 1;
inline bool ModeListResponse_Mode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModeListResponse_Mode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModeListResponse_Mode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModeListResponse_Mode::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ModeListResponse_Mode::id() const {
  return *id_;
}
inline void ModeListResponse_Mode::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ModeListResponse_Mode::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ModeListResponse_Mode::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeListResponse_Mode::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ModeListResponse_Mode::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModeListResponse_Mode::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool ModeListResponse_Mode::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModeListResponse_Mode::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModeListResponse_Mode::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModeListResponse_Mode::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModeListResponse_Mode::name() const {
  return *name_;
}
inline void ModeListResponse_Mode::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModeListResponse_Mode::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModeListResponse_Mode::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeListResponse_Mode::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModeListResponse_Mode::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModeListResponse_Mode::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string icon = 3;
inline bool ModeListResponse_Mode::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModeListResponse_Mode::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModeListResponse_Mode::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModeListResponse_Mode::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& ModeListResponse_Mode::icon() const {
  return *icon_;
}
inline void ModeListResponse_Mode::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void ModeListResponse_Mode::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void ModeListResponse_Mode::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeListResponse_Mode::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* ModeListResponse_Mode::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModeListResponse_Mode::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 limit = 4;
inline bool ModeListResponse_Mode::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModeListResponse_Mode::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModeListResponse_Mode::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModeListResponse_Mode::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 ModeListResponse_Mode::limit() const {
  return limit_;
}
inline void ModeListResponse_Mode::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// required string desc = 5;
inline bool ModeListResponse_Mode::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModeListResponse_Mode::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModeListResponse_Mode::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModeListResponse_Mode::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& ModeListResponse_Mode::desc() const {
  return *desc_;
}
inline void ModeListResponse_Mode::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void ModeListResponse_Mode::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void ModeListResponse_Mode::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeListResponse_Mode::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* ModeListResponse_Mode::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModeListResponse_Mode::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool team = 6;
inline bool ModeListResponse_Mode::has_team() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModeListResponse_Mode::set_has_team() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModeListResponse_Mode::clear_has_team() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModeListResponse_Mode::clear_team() {
  team_ = false;
  clear_has_team();
}
inline bool ModeListResponse_Mode::team() const {
  return team_;
}
inline void ModeListResponse_Mode::set_team(bool value) {
  set_has_team();
  team_ = value;
}

// repeated string maps = 7;
inline int ModeListResponse_Mode::maps_size() const {
  return maps_.size();
}
inline void ModeListResponse_Mode::clear_maps() {
  maps_.Clear();
}
inline const ::std::string& ModeListResponse_Mode::maps(int index) const {
  return maps_.Get(index);
}
inline ::std::string* ModeListResponse_Mode::mutable_maps(int index) {
  return maps_.Mutable(index);
}
inline void ModeListResponse_Mode::set_maps(int index, const ::std::string& value) {
  maps_.Mutable(index)->assign(value);
}
inline void ModeListResponse_Mode::set_maps(int index, const char* value) {
  maps_.Mutable(index)->assign(value);
}
inline void ModeListResponse_Mode::set_maps(int index, const char* value, size_t size) {
  maps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeListResponse_Mode::add_maps() {
  return maps_.Add();
}
inline void ModeListResponse_Mode::add_maps(const ::std::string& value) {
  maps_.Add()->assign(value);
}
inline void ModeListResponse_Mode::add_maps(const char* value) {
  maps_.Add()->assign(value);
}
inline void ModeListResponse_Mode::add_maps(const char* value, size_t size) {
  maps_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModeListResponse_Mode::maps() const {
  return maps_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModeListResponse_Mode::mutable_maps() {
  return &maps_;
}

// -------------------------------------------------------------------

// ModeListResponse

// repeated .com.tiange.mdsj.proto.ModeListResponse.Mode modes = 1;
inline int ModeListResponse::modes_size() const {
  return modes_.size();
}
inline void ModeListResponse::clear_modes() {
  modes_.Clear();
}
inline const ::com::tiange::mdsj::proto::ModeListResponse_Mode& ModeListResponse::modes(int index) const {
  return modes_.Get(index);
}
inline ::com::tiange::mdsj::proto::ModeListResponse_Mode* ModeListResponse::mutable_modes(int index) {
  return modes_.Mutable(index);
}
inline ::com::tiange::mdsj::proto::ModeListResponse_Mode* ModeListResponse::add_modes() {
  return modes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::ModeListResponse_Mode >&
ModeListResponse::modes() const {
  return modes_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::ModeListResponse_Mode >*
ModeListResponse::mutable_modes() {
  return &modes_;
}

// -------------------------------------------------------------------

// RoomListRequest

// -------------------------------------------------------------------

// RoomListResponse_Room

// required string id = 1;
inline bool RoomListResponse_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomListResponse_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomListResponse_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomListResponse_Room::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RoomListResponse_Room::id() const {
  return *id_;
}
inline void RoomListResponse_Room::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RoomListResponse_Room::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RoomListResponse_Room::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomListResponse_Room::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* RoomListResponse_Room::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomListResponse_Room::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool RoomListResponse_Room::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomListResponse_Room::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomListResponse_Room::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomListResponse_Room::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomListResponse_Room::name() const {
  return *name_;
}
inline void RoomListResponse_Room::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomListResponse_Room::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomListResponse_Room::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomListResponse_Room::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoomListResponse_Room::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomListResponse_Room::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 leader = 3;
inline bool RoomListResponse_Room::has_leader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomListResponse_Room::set_has_leader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomListResponse_Room::clear_has_leader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomListResponse_Room::clear_leader() {
  leader_ = 0;
  clear_has_leader();
}
inline ::google::protobuf::int32 RoomListResponse_Room::leader() const {
  return leader_;
}
inline void RoomListResponse_Room::set_leader(::google::protobuf::int32 value) {
  set_has_leader();
  leader_ = value;
}

// required string nick = 4;
inline bool RoomListResponse_Room::has_nick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomListResponse_Room::set_has_nick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomListResponse_Room::clear_has_nick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomListResponse_Room::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& RoomListResponse_Room::nick() const {
  return *nick_;
}
inline void RoomListResponse_Room::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RoomListResponse_Room::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RoomListResponse_Room::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomListResponse_Room::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* RoomListResponse_Room::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomListResponse_Room::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string modeId = 5;
inline bool RoomListResponse_Room::has_modeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomListResponse_Room::set_has_modeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomListResponse_Room::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomListResponse_Room::clear_modeid() {
  if (modeid_ != &::google::protobuf::internal::kEmptyString) {
    modeid_->clear();
  }
  clear_has_modeid();
}
inline const ::std::string& RoomListResponse_Room::modeid() const {
  return *modeid_;
}
inline void RoomListResponse_Room::set_modeid(const ::std::string& value) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(value);
}
inline void RoomListResponse_Room::set_modeid(const char* value) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(value);
}
inline void RoomListResponse_Room::set_modeid(const char* value, size_t size) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomListResponse_Room::mutable_modeid() {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  return modeid_;
}
inline ::std::string* RoomListResponse_Room::release_modeid() {
  clear_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modeid_;
    modeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomListResponse_Room::set_allocated_modeid(::std::string* modeid) {
  if (modeid_ != &::google::protobuf::internal::kEmptyString) {
    delete modeid_;
  }
  if (modeid) {
    set_has_modeid();
    modeid_ = modeid;
  } else {
    clear_has_modeid();
    modeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 limit = 6;
inline bool RoomListResponse_Room::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomListResponse_Room::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomListResponse_Room::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomListResponse_Room::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 RoomListResponse_Room::limit() const {
  return limit_;
}
inline void RoomListResponse_Room::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// required int32 num = 7;
inline bool RoomListResponse_Room::has_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomListResponse_Room::set_has_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomListResponse_Room::clear_has_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomListResponse_Room::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 RoomListResponse_Room::num() const {
  return num_;
}
inline void RoomListResponse_Room::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required bool needPwd = 8;
inline bool RoomListResponse_Room::has_needpwd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomListResponse_Room::set_has_needpwd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomListResponse_Room::clear_has_needpwd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomListResponse_Room::clear_needpwd() {
  needpwd_ = false;
  clear_has_needpwd();
}
inline bool RoomListResponse_Room::needpwd() const {
  return needpwd_;
}
inline void RoomListResponse_Room::set_needpwd(bool value) {
  set_has_needpwd();
  needpwd_ = value;
}

// required string map = 9;
inline bool RoomListResponse_Room::has_map() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomListResponse_Room::set_has_map() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomListResponse_Room::clear_has_map() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomListResponse_Room::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& RoomListResponse_Room::map() const {
  return *map_;
}
inline void RoomListResponse_Room::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void RoomListResponse_Room::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void RoomListResponse_Room::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomListResponse_Room::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* RoomListResponse_Room::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomListResponse_Room::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 10;
inline bool RoomListResponse_Room::has_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomListResponse_Room::set_has_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomListResponse_Room::clear_has_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomListResponse_Room::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RoomListResponse_Room::level() const {
  return level_;
}
inline void RoomListResponse_Room::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 time = 11;
inline bool RoomListResponse_Room::has_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomListResponse_Room::set_has_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomListResponse_Room::clear_has_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomListResponse_Room::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 RoomListResponse_Room::time() const {
  return time_;
}
inline void RoomListResponse_Room::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// RoomListResponse

// repeated .com.tiange.mdsj.proto.RoomListResponse.Room rooms = 1;
inline int RoomListResponse::rooms_size() const {
  return rooms_.size();
}
inline void RoomListResponse::clear_rooms() {
  rooms_.Clear();
}
inline const ::com::tiange::mdsj::proto::RoomListResponse_Room& RoomListResponse::rooms(int index) const {
  return rooms_.Get(index);
}
inline ::com::tiange::mdsj::proto::RoomListResponse_Room* RoomListResponse::mutable_rooms(int index) {
  return rooms_.Mutable(index);
}
inline ::com::tiange::mdsj::proto::RoomListResponse_Room* RoomListResponse::add_rooms() {
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::RoomListResponse_Room >&
RoomListResponse::rooms() const {
  return rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::RoomListResponse_Room >*
RoomListResponse::mutable_rooms() {
  return &rooms_;
}

// -------------------------------------------------------------------

// CreateRoomRequest

// required string modeId = 1;
inline bool CreateRoomRequest::has_modeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRequest::set_has_modeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRequest::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRequest::clear_modeid() {
  if (modeid_ != &::google::protobuf::internal::kEmptyString) {
    modeid_->clear();
  }
  clear_has_modeid();
}
inline const ::std::string& CreateRoomRequest::modeid() const {
  return *modeid_;
}
inline void CreateRoomRequest::set_modeid(const ::std::string& value) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(value);
}
inline void CreateRoomRequest::set_modeid(const char* value) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(value);
}
inline void CreateRoomRequest::set_modeid(const char* value, size_t size) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomRequest::mutable_modeid() {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  return modeid_;
}
inline ::std::string* CreateRoomRequest::release_modeid() {
  clear_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modeid_;
    modeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomRequest::set_allocated_modeid(::std::string* modeid) {
  if (modeid_ != &::google::protobuf::internal::kEmptyString) {
    delete modeid_;
  }
  if (modeid) {
    set_has_modeid();
    modeid_ = modeid;
  } else {
    clear_has_modeid();
    modeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool CreateRoomRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateRoomRequest::name() const {
  return *name_;
}
inline void CreateRoomRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoomRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoomRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateRoomRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pwd = 3;
inline bool CreateRoomRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomRequest::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& CreateRoomRequest::pwd() const {
  return *pwd_;
}
inline void CreateRoomRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void CreateRoomRequest::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void CreateRoomRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomRequest::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* CreateRoomRequest::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 mode = 4;
inline bool CreateRoomRequest::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomRequest::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomRequest::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomRequest::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 CreateRoomRequest::mode() const {
  return mode_;
}
inline void CreateRoomRequest::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
}

// required int32 match = 5;
inline bool CreateRoomRequest::has_match() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomRequest::set_has_match() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomRequest::clear_has_match() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomRequest::clear_match() {
  match_ = 0;
  clear_has_match();
}
inline ::google::protobuf::int32 CreateRoomRequest::match() const {
  return match_;
}
inline void CreateRoomRequest::set_match(::google::protobuf::int32 value) {
  set_has_match();
  match_ = value;
}

// -------------------------------------------------------------------

// CreateRoomResponse

// required int32 result = 1;
inline bool CreateRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CreateRoomResponse::result() const {
  return result_;
}
inline void CreateRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string id = 2;
inline bool CreateRoomResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CreateRoomResponse::id() const {
  return *id_;
}
inline void CreateRoomResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CreateRoomResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CreateRoomResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CreateRoomResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool CreateRoomResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateRoomResponse::name() const {
  return *name_;
}
inline void CreateRoomResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoomResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoomResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateRoomResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string map = 4;
inline bool CreateRoomResponse::has_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomResponse::set_has_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomResponse::clear_has_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomResponse::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& CreateRoomResponse::map() const {
  return *map_;
}
inline void CreateRoomResponse::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void CreateRoomResponse::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void CreateRoomResponse::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomResponse::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* CreateRoomResponse::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomResponse::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 role = 5;
inline bool CreateRoomResponse::has_role() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomResponse::set_has_role() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomResponse::clear_has_role() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomResponse::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 CreateRoomResponse::role() const {
  return role_;
}
inline void CreateRoomResponse::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// optional string nick = 6;
inline bool CreateRoomResponse::has_nick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateRoomResponse::set_has_nick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateRoomResponse::clear_has_nick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateRoomResponse::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CreateRoomResponse::nick() const {
  return *nick_;
}
inline void CreateRoomResponse::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CreateRoomResponse::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CreateRoomResponse::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomResponse::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CreateRoomResponse::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomResponse::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 7;
inline bool CreateRoomResponse::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateRoomResponse::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateRoomResponse::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateRoomResponse::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CreateRoomResponse::level() const {
  return level_;
}
inline void CreateRoomResponse::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional string avatar = 8;
inline bool CreateRoomResponse::has_avatar() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateRoomResponse::set_has_avatar() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateRoomResponse::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateRoomResponse::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& CreateRoomResponse::avatar() const {
  return *avatar_;
}
inline void CreateRoomResponse::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void CreateRoomResponse::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void CreateRoomResponse::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomResponse::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* CreateRoomResponse::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomResponse::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnterRoomRequest

// required string id = 1;
inline bool EnterRoomRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& EnterRoomRequest::id() const {
  return *id_;
}
inline void EnterRoomRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void EnterRoomRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void EnterRoomRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* EnterRoomRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pwd = 2;
inline bool EnterRoomRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomRequest::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& EnterRoomRequest::pwd() const {
  return *pwd_;
}
inline void EnterRoomRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void EnterRoomRequest::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void EnterRoomRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomRequest::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* EnterRoomRequest::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnterRoomResponse_Member

// required string role = 1;
inline bool EnterRoomResponse_Member::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomResponse_Member::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomResponse_Member::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomResponse_Member::clear_role() {
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& EnterRoomResponse_Member::role() const {
  return *role_;
}
inline void EnterRoomResponse_Member::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void EnterRoomResponse_Member::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void EnterRoomResponse_Member::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomResponse_Member::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  return role_;
}
inline ::std::string* EnterRoomResponse_Member::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomResponse_Member::set_allocated_role(::std::string* role) {
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nick = 2;
inline bool EnterRoomResponse_Member::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomResponse_Member::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomResponse_Member::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomResponse_Member::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& EnterRoomResponse_Member::nick() const {
  return *nick_;
}
inline void EnterRoomResponse_Member::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void EnterRoomResponse_Member::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void EnterRoomResponse_Member::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomResponse_Member::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* EnterRoomResponse_Member::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomResponse_Member::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool EnterRoomResponse_Member::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoomResponse_Member::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoomResponse_Member::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoomResponse_Member::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 EnterRoomResponse_Member::level() const {
  return level_;
}
inline void EnterRoomResponse_Member::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string avatar = 4;
inline bool EnterRoomResponse_Member::has_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoomResponse_Member::set_has_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoomResponse_Member::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoomResponse_Member::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& EnterRoomResponse_Member::avatar() const {
  return *avatar_;
}
inline void EnterRoomResponse_Member::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void EnterRoomResponse_Member::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void EnterRoomResponse_Member::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomResponse_Member::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* EnterRoomResponse_Member::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomResponse_Member::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool leader = 5;
inline bool EnterRoomResponse_Member::has_leader() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnterRoomResponse_Member::set_has_leader() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnterRoomResponse_Member::clear_has_leader() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnterRoomResponse_Member::clear_leader() {
  leader_ = false;
  clear_has_leader();
}
inline bool EnterRoomResponse_Member::leader() const {
  return leader_;
}
inline void EnterRoomResponse_Member::set_leader(bool value) {
  set_has_leader();
  leader_ = value;
}

// -------------------------------------------------------------------

// EnterRoomResponse

// required int32 result = 1;
inline bool EnterRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 EnterRoomResponse::result() const {
  return result_;
}
inline void EnterRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string id = 2;
inline bool EnterRoomResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& EnterRoomResponse::id() const {
  return *id_;
}
inline void EnterRoomResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void EnterRoomResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void EnterRoomResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* EnterRoomResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool EnterRoomResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoomResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoomResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoomResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EnterRoomResponse::name() const {
  return *name_;
}
inline void EnterRoomResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EnterRoomResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EnterRoomResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* EnterRoomResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string map = 4;
inline bool EnterRoomResponse::has_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoomResponse::set_has_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoomResponse::clear_has_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoomResponse::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& EnterRoomResponse::map() const {
  return *map_;
}
inline void EnterRoomResponse::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void EnterRoomResponse::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void EnterRoomResponse::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomResponse::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* EnterRoomResponse::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomResponse::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.tiange.mdsj.proto.EnterRoomResponse.Member members = 5;
inline int EnterRoomResponse::members_size() const {
  return members_.size();
}
inline void EnterRoomResponse::clear_members() {
  members_.Clear();
}
inline const ::com::tiange::mdsj::proto::EnterRoomResponse_Member& EnterRoomResponse::members(int index) const {
  return members_.Get(index);
}
inline ::com::tiange::mdsj::proto::EnterRoomResponse_Member* EnterRoomResponse::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::com::tiange::mdsj::proto::EnterRoomResponse_Member* EnterRoomResponse::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::EnterRoomResponse_Member >&
EnterRoomResponse::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::EnterRoomResponse_Member >*
EnterRoomResponse::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// SearchRoomRequest

// required string id = 1;
inline bool SearchRoomRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRoomRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRoomRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRoomRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SearchRoomRequest::id() const {
  return *id_;
}
inline void SearchRoomRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SearchRoomRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SearchRoomRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRoomRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SearchRoomRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRoomRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SearchRoomResponse

// required int32 result = 1;
inline bool SearchRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 SearchRoomResponse::result() const {
  return result_;
}
inline void SearchRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string id = 2;
inline bool SearchRoomResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchRoomResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchRoomResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchRoomResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SearchRoomResponse::id() const {
  return *id_;
}
inline void SearchRoomResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SearchRoomResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SearchRoomResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRoomResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SearchRoomResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRoomResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool SearchRoomResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchRoomResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchRoomResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchRoomResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SearchRoomResponse::name() const {
  return *name_;
}
inline void SearchRoomResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SearchRoomResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SearchRoomResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRoomResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SearchRoomResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRoomResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool status = 4;
inline bool SearchRoomResponse::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchRoomResponse::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchRoomResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchRoomResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool SearchRoomResponse::status() const {
  return status_;
}
inline void SearchRoomResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// optional bool needPwd = 5;
inline bool SearchRoomResponse::has_needpwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchRoomResponse::set_has_needpwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchRoomResponse::clear_has_needpwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchRoomResponse::clear_needpwd() {
  needpwd_ = false;
  clear_has_needpwd();
}
inline bool SearchRoomResponse::needpwd() const {
  return needpwd_;
}
inline void SearchRoomResponse::set_needpwd(bool value) {
  set_has_needpwd();
  needpwd_ = value;
}

// -------------------------------------------------------------------

// FastEnterRequest

// -------------------------------------------------------------------

// FastEnterResponse_Member

// required int32 role = 1;
inline bool FastEnterResponse_Member::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastEnterResponse_Member::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastEnterResponse_Member::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastEnterResponse_Member::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 FastEnterResponse_Member::role() const {
  return role_;
}
inline void FastEnterResponse_Member::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// required string nick = 2;
inline bool FastEnterResponse_Member::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastEnterResponse_Member::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastEnterResponse_Member::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastEnterResponse_Member::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& FastEnterResponse_Member::nick() const {
  return *nick_;
}
inline void FastEnterResponse_Member::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void FastEnterResponse_Member::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void FastEnterResponse_Member::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastEnterResponse_Member::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* FastEnterResponse_Member::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastEnterResponse_Member::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool FastEnterResponse_Member::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FastEnterResponse_Member::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FastEnterResponse_Member::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FastEnterResponse_Member::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 FastEnterResponse_Member::level() const {
  return level_;
}
inline void FastEnterResponse_Member::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string avatar = 4;
inline bool FastEnterResponse_Member::has_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FastEnterResponse_Member::set_has_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FastEnterResponse_Member::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FastEnterResponse_Member::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& FastEnterResponse_Member::avatar() const {
  return *avatar_;
}
inline void FastEnterResponse_Member::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void FastEnterResponse_Member::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void FastEnterResponse_Member::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastEnterResponse_Member::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* FastEnterResponse_Member::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastEnterResponse_Member::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool leader = 5;
inline bool FastEnterResponse_Member::has_leader() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FastEnterResponse_Member::set_has_leader() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FastEnterResponse_Member::clear_has_leader() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FastEnterResponse_Member::clear_leader() {
  leader_ = false;
  clear_has_leader();
}
inline bool FastEnterResponse_Member::leader() const {
  return leader_;
}
inline void FastEnterResponse_Member::set_leader(bool value) {
  set_has_leader();
  leader_ = value;
}

// required int32 index = 6;
inline bool FastEnterResponse_Member::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FastEnterResponse_Member::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FastEnterResponse_Member::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FastEnterResponse_Member::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 FastEnterResponse_Member::index() const {
  return index_;
}
inline void FastEnterResponse_Member::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// FastEnterResponse

// required int32 result = 1;
inline bool FastEnterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastEnterResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastEnterResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastEnterResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 FastEnterResponse::result() const {
  return result_;
}
inline void FastEnterResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string id = 2;
inline bool FastEnterResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastEnterResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastEnterResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastEnterResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FastEnterResponse::id() const {
  return *id_;
}
inline void FastEnterResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FastEnterResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FastEnterResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastEnterResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FastEnterResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastEnterResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool FastEnterResponse::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FastEnterResponse::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FastEnterResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FastEnterResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FastEnterResponse::name() const {
  return *name_;
}
inline void FastEnterResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FastEnterResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FastEnterResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastEnterResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FastEnterResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastEnterResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string map = 4;
inline bool FastEnterResponse::has_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FastEnterResponse::set_has_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FastEnterResponse::clear_has_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FastEnterResponse::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& FastEnterResponse::map() const {
  return *map_;
}
inline void FastEnterResponse::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void FastEnterResponse::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void FastEnterResponse::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastEnterResponse::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* FastEnterResponse::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FastEnterResponse::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.tiange.mdsj.proto.FastEnterResponse.Member members = 5;
inline int FastEnterResponse::members_size() const {
  return members_.size();
}
inline void FastEnterResponse::clear_members() {
  members_.Clear();
}
inline const ::com::tiange::mdsj::proto::FastEnterResponse_Member& FastEnterResponse::members(int index) const {
  return members_.Get(index);
}
inline ::com::tiange::mdsj::proto::FastEnterResponse_Member* FastEnterResponse::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::com::tiange::mdsj::proto::FastEnterResponse_Member* FastEnterResponse::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::FastEnterResponse_Member >&
FastEnterResponse::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::FastEnterResponse_Member >*
FastEnterResponse::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// ModifyRequest

// -------------------------------------------------------------------

// ModifyResponse

// -------------------------------------------------------------------

// StartRequest

// -------------------------------------------------------------------

// StartResponse

// required int32 result = 1;
inline bool StartResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 StartResponse::result() const {
  return result_;
}
inline void StartResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// PrepareRequest

// -------------------------------------------------------------------

// PrepareResponse

// required int32 result = 1;
inline bool PrepareResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepareResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrepareResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrepareResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PrepareResponse::result() const {
  return result_;
}
inline void PrepareResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// OnlinesRequest

// -------------------------------------------------------------------

// OnlinesResponse_User

// required int32 role = 1;
inline bool OnlinesResponse_User::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlinesResponse_User::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlinesResponse_User::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlinesResponse_User::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 OnlinesResponse_User::role() const {
  return role_;
}
inline void OnlinesResponse_User::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// required string nick = 2;
inline bool OnlinesResponse_User::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlinesResponse_User::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlinesResponse_User::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlinesResponse_User::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& OnlinesResponse_User::nick() const {
  return *nick_;
}
inline void OnlinesResponse_User::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void OnlinesResponse_User::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void OnlinesResponse_User::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnlinesResponse_User::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* OnlinesResponse_User::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OnlinesResponse_User::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool OnlinesResponse_User::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnlinesResponse_User::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnlinesResponse_User::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnlinesResponse_User::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 OnlinesResponse_User::level() const {
  return level_;
}
inline void OnlinesResponse_User::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string avatar = 4;
inline bool OnlinesResponse_User::has_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OnlinesResponse_User::set_has_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OnlinesResponse_User::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OnlinesResponse_User::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& OnlinesResponse_User::avatar() const {
  return *avatar_;
}
inline void OnlinesResponse_User::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void OnlinesResponse_User::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void OnlinesResponse_User::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnlinesResponse_User::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* OnlinesResponse_User::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OnlinesResponse_User::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool sex = 5;
inline bool OnlinesResponse_User::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OnlinesResponse_User::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OnlinesResponse_User::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OnlinesResponse_User::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool OnlinesResponse_User::sex() const {
  return sex_;
}
inline void OnlinesResponse_User::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// OnlinesResponse

// repeated .com.tiange.mdsj.proto.OnlinesResponse.User users = 1;
inline int OnlinesResponse::users_size() const {
  return users_.size();
}
inline void OnlinesResponse::clear_users() {
  users_.Clear();
}
inline const ::com::tiange::mdsj::proto::OnlinesResponse_User& OnlinesResponse::users(int index) const {
  return users_.Get(index);
}
inline ::com::tiange::mdsj::proto::OnlinesResponse_User* OnlinesResponse::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::com::tiange::mdsj::proto::OnlinesResponse_User* OnlinesResponse::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::OnlinesResponse_User >&
OnlinesResponse::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tiange::mdsj::proto::OnlinesResponse_User >*
OnlinesResponse::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// InviteRequest

// required int32 role = 1;
inline bool InviteRequest::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteRequest::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteRequest::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteRequest::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 InviteRequest::role() const {
  return role_;
}
inline void InviteRequest::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// -------------------------------------------------------------------

// InviteResponse

// required int32 result = 1;
inline bool InviteResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 InviteResponse::result() const {
  return result_;
}
inline void InviteResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SearchRoleRequest

// required int32 role = 1;
inline bool SearchRoleRequest::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRoleRequest::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRoleRequest::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRoleRequest::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 SearchRoleRequest::role() const {
  return role_;
}
inline void SearchRoleRequest::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// -------------------------------------------------------------------

// SearchRoleResponse

// required int32 role = 1;
inline bool SearchRoleResponse::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRoleResponse::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRoleResponse::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRoleResponse::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 SearchRoleResponse::role() const {
  return role_;
}
inline void SearchRoleResponse::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// required string nick = 2;
inline bool SearchRoleResponse::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchRoleResponse::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchRoleResponse::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchRoleResponse::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& SearchRoleResponse::nick() const {
  return *nick_;
}
inline void SearchRoleResponse::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void SearchRoleResponse::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void SearchRoleResponse::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRoleResponse::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* SearchRoleResponse::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRoleResponse::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool SearchRoleResponse::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchRoleResponse::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchRoleResponse::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchRoleResponse::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SearchRoleResponse::level() const {
  return level_;
}
inline void SearchRoleResponse::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string avatar = 4;
inline bool SearchRoleResponse::has_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchRoleResponse::set_has_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchRoleResponse::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchRoleResponse::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& SearchRoleResponse::avatar() const {
  return *avatar_;
}
inline void SearchRoleResponse::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void SearchRoleResponse::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void SearchRoleResponse::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchRoleResponse::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* SearchRoleResponse::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchRoleResponse::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool sex = 5;
inline bool SearchRoleResponse::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchRoleResponse::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchRoleResponse::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchRoleResponse::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool SearchRoleResponse::sex() const {
  return sex_;
}
inline void SearchRoleResponse::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// ExitRequest

// -------------------------------------------------------------------

// ExitResponse

// required int32 result = 1;
inline bool ExitResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ExitResponse::result() const {
  return result_;
}
inline void ExitResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// InvitePush

// required int32 role = 1;
inline bool InvitePush::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitePush::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitePush::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitePush::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 InvitePush::role() const {
  return role_;
}
inline void InvitePush::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// required string nick = 2;
inline bool InvitePush::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitePush::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitePush::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitePush::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& InvitePush::nick() const {
  return *nick_;
}
inline void InvitePush::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void InvitePush::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void InvitePush::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitePush::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* InvitePush::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitePush::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string room = 3;
inline bool InvitePush::has_room() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvitePush::set_has_room() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvitePush::clear_has_room() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvitePush::clear_room() {
  if (room_ != &::google::protobuf::internal::kEmptyString) {
    room_->clear();
  }
  clear_has_room();
}
inline const ::std::string& InvitePush::room() const {
  return *room_;
}
inline void InvitePush::set_room(const ::std::string& value) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(value);
}
inline void InvitePush::set_room(const char* value) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(value);
}
inline void InvitePush::set_room(const char* value, size_t size) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitePush::mutable_room() {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  return room_;
}
inline ::std::string* InvitePush::release_room() {
  clear_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_;
    room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitePush::set_allocated_room(::std::string* room) {
  if (room_ != &::google::protobuf::internal::kEmptyString) {
    delete room_;
  }
  if (room) {
    set_has_room();
    room_ = room;
  } else {
    clear_has_room();
    room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RefusePush

// required int32 role = 1;
inline bool RefusePush::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefusePush::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefusePush::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefusePush::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 RefusePush::role() const {
  return role_;
}
inline void RefusePush::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// required string nick = 2;
inline bool RefusePush::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RefusePush::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RefusePush::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RefusePush::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& RefusePush::nick() const {
  return *nick_;
}
inline void RefusePush::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RefusePush::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RefusePush::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefusePush::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* RefusePush::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RefusePush::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomStatusPush

// required int32 type = 1;
inline bool RoomStatusPush::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomStatusPush::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomStatusPush::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomStatusPush::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RoomStatusPush::type() const {
  return type_;
}
inline void RoomStatusPush::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string id = 2;
inline bool RoomStatusPush::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomStatusPush::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomStatusPush::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomStatusPush::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& RoomStatusPush::id() const {
  return *id_;
}
inline void RoomStatusPush::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RoomStatusPush::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void RoomStatusPush::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomStatusPush::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* RoomStatusPush::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomStatusPush::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool RoomStatusPush::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomStatusPush::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomStatusPush::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomStatusPush::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomStatusPush::name() const {
  return *name_;
}
inline void RoomStatusPush::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomStatusPush::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomStatusPush::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomStatusPush::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoomStatusPush::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomStatusPush::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 leader = 4;
inline bool RoomStatusPush::has_leader() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomStatusPush::set_has_leader() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomStatusPush::clear_has_leader() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomStatusPush::clear_leader() {
  leader_ = 0;
  clear_has_leader();
}
inline ::google::protobuf::int32 RoomStatusPush::leader() const {
  return leader_;
}
inline void RoomStatusPush::set_leader(::google::protobuf::int32 value) {
  set_has_leader();
  leader_ = value;
}

// required string nick = 5;
inline bool RoomStatusPush::has_nick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomStatusPush::set_has_nick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomStatusPush::clear_has_nick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomStatusPush::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& RoomStatusPush::nick() const {
  return *nick_;
}
inline void RoomStatusPush::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RoomStatusPush::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RoomStatusPush::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomStatusPush::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* RoomStatusPush::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomStatusPush::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string modeId = 6;
inline bool RoomStatusPush::has_modeid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomStatusPush::set_has_modeid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomStatusPush::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomStatusPush::clear_modeid() {
  if (modeid_ != &::google::protobuf::internal::kEmptyString) {
    modeid_->clear();
  }
  clear_has_modeid();
}
inline const ::std::string& RoomStatusPush::modeid() const {
  return *modeid_;
}
inline void RoomStatusPush::set_modeid(const ::std::string& value) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(value);
}
inline void RoomStatusPush::set_modeid(const char* value) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(value);
}
inline void RoomStatusPush::set_modeid(const char* value, size_t size) {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  modeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomStatusPush::mutable_modeid() {
  set_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    modeid_ = new ::std::string;
  }
  return modeid_;
}
inline ::std::string* RoomStatusPush::release_modeid() {
  clear_has_modeid();
  if (modeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modeid_;
    modeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomStatusPush::set_allocated_modeid(::std::string* modeid) {
  if (modeid_ != &::google::protobuf::internal::kEmptyString) {
    delete modeid_;
  }
  if (modeid) {
    set_has_modeid();
    modeid_ = modeid;
  } else {
    clear_has_modeid();
    modeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 limit = 7;
inline bool RoomStatusPush::has_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomStatusPush::set_has_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomStatusPush::clear_has_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomStatusPush::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 RoomStatusPush::limit() const {
  return limit_;
}
inline void RoomStatusPush::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// required int32 num = 8;
inline bool RoomStatusPush::has_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomStatusPush::set_has_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomStatusPush::clear_has_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomStatusPush::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 RoomStatusPush::num() const {
  return num_;
}
inline void RoomStatusPush::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required bool needPwd = 9;
inline bool RoomStatusPush::has_needpwd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomStatusPush::set_has_needpwd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomStatusPush::clear_has_needpwd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomStatusPush::clear_needpwd() {
  needpwd_ = false;
  clear_has_needpwd();
}
inline bool RoomStatusPush::needpwd() const {
  return needpwd_;
}
inline void RoomStatusPush::set_needpwd(bool value) {
  set_has_needpwd();
  needpwd_ = value;
}

// required string map = 10;
inline bool RoomStatusPush::has_map() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomStatusPush::set_has_map() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomStatusPush::clear_has_map() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomStatusPush::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& RoomStatusPush::map() const {
  return *map_;
}
inline void RoomStatusPush::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void RoomStatusPush::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void RoomStatusPush::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomStatusPush::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* RoomStatusPush::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomStatusPush::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 11;
inline bool RoomStatusPush::has_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomStatusPush::set_has_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomStatusPush::clear_has_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomStatusPush::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RoomStatusPush::level() const {
  return level_;
}
inline void RoomStatusPush::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 time = 12;
inline bool RoomStatusPush::has_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RoomStatusPush::set_has_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RoomStatusPush::clear_has_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RoomStatusPush::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 RoomStatusPush::time() const {
  return time_;
}
inline void RoomStatusPush::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// MapChangePush

// required string map = 1;
inline bool MapChangePush::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapChangePush::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapChangePush::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapChangePush::clear_map() {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    map_->clear();
  }
  clear_has_map();
}
inline const ::std::string& MapChangePush::map() const {
  return *map_;
}
inline void MapChangePush::set_map(const ::std::string& value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void MapChangePush::set_map(const char* value) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(value);
}
inline void MapChangePush::set_map(const char* value, size_t size) {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapChangePush::mutable_map() {
  set_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    map_ = new ::std::string;
  }
  return map_;
}
inline ::std::string* MapChangePush::release_map() {
  clear_has_map();
  if (map_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_;
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapChangePush::set_allocated_map(::std::string* map) {
  if (map_ != &::google::protobuf::internal::kEmptyString) {
    delete map_;
  }
  if (map) {
    set_has_map();
    map_ = map;
  } else {
    clear_has_map();
    map_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoleChangePush

// required int32 type = 1;
inline bool RoleChangePush::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleChangePush::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleChangePush::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleChangePush::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RoleChangePush::type() const {
  return type_;
}
inline void RoleChangePush::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 role = 2;
inline bool RoleChangePush::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleChangePush::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleChangePush::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleChangePush::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::google::protobuf::int32 RoleChangePush::role() const {
  return role_;
}
inline void RoleChangePush::set_role(::google::protobuf::int32 value) {
  set_has_role();
  role_ = value;
}

// required string nick = 3;
inline bool RoleChangePush::has_nick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleChangePush::set_has_nick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleChangePush::clear_has_nick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleChangePush::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& RoleChangePush::nick() const {
  return *nick_;
}
inline void RoleChangePush::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RoleChangePush::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void RoleChangePush::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleChangePush::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* RoleChangePush::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleChangePush::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 4;
inline bool RoleChangePush::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleChangePush::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleChangePush::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleChangePush::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RoleChangePush::level() const {
  return level_;
}
inline void RoleChangePush::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string avatar = 5;
inline bool RoleChangePush::has_avatar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoleChangePush::set_has_avatar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoleChangePush::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoleChangePush::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& RoleChangePush::avatar() const {
  return *avatar_;
}
inline void RoleChangePush::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void RoleChangePush::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void RoleChangePush::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleChangePush::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* RoleChangePush::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleChangePush::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool leader = 6;
inline bool RoleChangePush::has_leader() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleChangePush::set_has_leader() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleChangePush::clear_has_leader() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleChangePush::clear_leader() {
  leader_ = false;
  clear_has_leader();
}
inline bool RoleChangePush::leader() const {
  return leader_;
}
inline void RoleChangePush::set_leader(bool value) {
  set_has_leader();
  leader_ = value;
}

// required int32 index = 7;
inline bool RoleChangePush::has_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoleChangePush::set_has_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoleChangePush::clear_has_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoleChangePush::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 RoleChangePush::index() const {
  return index_;
}
inline void RoleChangePush::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace mdsj
}  // namespace tiange
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AthleticProto_2eproto__INCLUDED
